"""
Сервис-коннектор для iiko Cloud API
"""
import json
import time
from typing import Optional
import httpx
from sqlalchemy.orm import Session
from sqlalchemy.sql import func as sa_func
from database.models import ApiLog, IikoSettings
from config.settings import settings

MAX_LOG_BODY_LENGTH = 2000


class IikoService:
    """Коннектор для работы с iiko Cloud API"""

    def __init__(self, db: Session, iiko_settings: Optional[IikoSettings] = None):
        self.db = db
        self.iiko_settings = iiko_settings
        self.base_url = (iiko_settings.api_url if iiko_settings else settings.IIKO_API_URL).rstrip("/")
        self._token: Optional[str] = None

    def _log_request(
        self,
        method: str,
        url: str,
        request_body: Optional[str],
        response_status: Optional[int],
        response_body: Optional[str],
        duration_ms: int,
    ):
        log = ApiLog(
            method=method,
            url=url,
            request_body=request_body,
            response_status=response_status,
            response_body=response_body[:MAX_LOG_BODY_LENGTH] if response_body else None,
            duration_ms=duration_ms,
        )
        self.db.add(log)
        self.db.commit()

    async def _request(
        self,
        method: str,
        path: str,
        json_data: Optional[dict] = None,
        headers: Optional[dict] = None,
        _retried: bool = False,
        _is_auth: bool = False,
    ) -> dict | str:
        url = f"{self.base_url}/{path.lstrip('/')}"
        req_body = json.dumps(json_data) if json_data else None
        hdrs = {
            "Content-Type": "application/json",
            "Timeout": "45",
        }
        if headers:
            hdrs.update(headers)
        if self._token and not _is_auth:
            hdrs["Authorization"] = f"Bearer {self._token}"

        start = time.time()
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.request(method, url, json=json_data, headers=hdrs)
        duration = int((time.time() - start) * 1000)

        resp_text = response.text
        self._log_request(method, url, req_body, response.status_code, resp_text, duration)

        # Auto-retry once on 401 (expired token), but NOT for auth requests
        if response.status_code == 401 and not _retried and not _is_auth:
            await self.authenticate()
            return await self._request(method, path, json_data, headers, _retried=True)

        if response.status_code >= 400:
            raise Exception(f"iiko API error {response.status_code}: {resp_text}")

        if not resp_text:
            return {}
        # iiko API may return plain text (e.g. access_token endpoint) or JSON
        try:
            return response.json()
        except Exception:
            return resp_text

    async def authenticate(self, api_key: Optional[str] = None) -> str:
        """Получить токен доступа iiko (токен живет ~15 минут)"""
        key = api_key or (self.iiko_settings.api_key if self.iiko_settings else settings.IIKO_API_KEY)
        key = key.strip()
        result = await self._request("POST", "/access_token", json_data={"apiLogin": key}, _is_auth=True)
        # iiko API may return token as plain text string or as JSON {"token": "..."}
        if isinstance(result, str):
            # Plain text response; strip whitespace and surrounding quotes
            # (iiko may return a bare JSON string like "token-value")
            token_str = result.strip()
            if len(token_str) >= 2 and token_str[0] == '"' and token_str[-1] == '"':
                token_str = token_str[1:-1]
            self._token = token_str
        elif isinstance(result, dict):
            # JSON response: try "token" (documented) or "access_token" (compatibility)
            self._token = result.get("token") or result.get("access_token") or ""
        else:
            self._token = str(result).strip()
        # Обновить время последнего обновления токена в БД
        if self.iiko_settings:
            self.iiko_settings.last_token_refresh = sa_func.now()
            self.db.commit()
        return self._token

    async def get_organizations(self) -> dict:
        """Получить список организаций"""
        if not self._token:
            await self.authenticate()
        return await self._request("POST", "/organizations", json_data={})

    async def get_menu(self, organization_id: str) -> dict:
        """Получить меню организации"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/nomenclature",
            json_data={"organizationId": organization_id},
        )

    async def create_order(self, organization_id: str, order_data: dict) -> dict:
        """Создать заказ в iiko"""
        if not self._token:
            await self.authenticate()
        payload = {"organizationId": organization_id, "order": order_data}
        return await self._request("POST", "/deliveries/create", json_data=payload)

    async def get_order_status(self, organization_id: str, order_ids: list) -> dict:
        """Получить статус заказов"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/deliveries/by_id",
            json_data={"organizationId": organization_id, "orderIds": order_ids},
        )

    async def get_stop_lists(self, organization_id: str) -> dict:
        """Получить стоп-листы"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/stop_lists",
            json_data={"organizationIds": [organization_id]},
        )

    async def get_terminal_groups(self, organization_ids: list) -> dict:
        """Получить терминальные группы (точки/заведения)"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/terminal_groups",
            json_data={"organizationIds": organization_ids},
        )

    async def get_payment_types(self, organization_ids: list) -> dict:
        """Получить доступные типы оплат"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/payment_types",
            json_data={"organizationIds": organization_ids},
        )

    async def get_couriers(self, organization_id: str) -> dict:
        """Получить список курьеров"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/employees/couriers",
            json_data={"organizationIds": [organization_id]},
        )

    async def get_order_types(self, organization_ids: list) -> dict:
        """Получить типы заказов"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/deliveries/order_types",
            json_data={"organizationIds": organization_ids},
        )

    async def get_discount_types(self, organization_ids: list) -> dict:
        """Получить типы скидок"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/discounts",
            json_data={"organizationIds": organization_ids},
        )

    async def register_webhook(self, organization_id: str, webhook_url: str, auth_token: str) -> dict:
        """Зарегистрировать вебхук в iiko"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/webhooks/update_settings",
            json_data={
                "organizationId": organization_id,
                "webHooksUri": webhook_url,
                "authToken": auth_token,
                "webHooksFilter": {
                    "deliveryOrderFilter": {
                        "orderStatuses": [
                            "Unconfirmed", "WaitCooking", "ReadyForCooking",
                            "CookingStarted", "CookingCompleted", "Waiting",
                            "OnWay", "Delivered", "Closed", "Cancelled"
                        ],
                        "itemStatuses": [
                            "Added", "PrintedNotCooking", "CookingStarted",
                            "CookingCompleted", "Served"
                        ],
                        "errors": True,
                    },
                    "tableOrderFilter": {
                        "orderStatuses": ["New"],
                        "itemStatuses": ["Added"],
                        "errors": True,
                    },
                    "reserveFilter": {
                        "updates": True,
                        "errors": True,
                    },
                    "stopListUpdateFilter": {
                        "updates": True,
                    },
                    "personalShiftFilter": {
                        "updates": True,
                    },
                },
            },
        )

    async def get_webhook_settings(self, organization_id: str) -> dict:
        """Получить текущие настройки вебхука"""
        if not self._token:
            await self.authenticate()
        return await self._request(
            "POST",
            "/webhooks/settings",
            json_data={"organizationId": organization_id},
        )

    async def get_deliveries_by_statuses(self, organization_id: str, statuses: list) -> dict:
        """Получить заказы по статусам"""
        if not self._token:
            await self.authenticate()
        from datetime import datetime, timedelta
        now = datetime.utcnow()
        date_from = (now - timedelta(days=7)).strftime("%Y-%m-%d %H:%M:%S.000")
        date_to = now.strftime("%Y-%m-%d %H:%M:%S.000")
        return await self._request(
            "POST",
            "/deliveries/by_delivery_date_and_status",
            json_data={
                "organizationIds": [organization_id],
                "deliveryDateFrom": date_from,
                "deliveryDateTo": date_to,
                "statuses": statuses,
            },
        )
